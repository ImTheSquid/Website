<canvas id="dotCanvas"></canvas>

<script>
  // WebGL setup
  const canvas = document.getElementById("dotCanvas") as HTMLCanvasElement;
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;

  const gl = canvas.getContext("webgl");
  if (!gl) {
    console.error("WebGL not supported!");
    throw new Error("WebGL not supported.");
  }

  // Vertex shader source
  const vertexShaderSrc = `
    precision mediump float;
    attribute vec2 a_position;  // Dot position (normalized)
    uniform vec2 u_resolution;  // Canvas resolution
    uniform vec2 u_mouse;
    uniform float u_radius;
    void main() {
      // Convert position to clip space [-1, 1]
      vec2 clipSpace = (a_position / u_resolution) * 2.0 - 1.0;
      gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);
      gl_PointSize = 4.0 + max(0.0, u_radius - distance(a_position, u_mouse)) / 30.0;  // Base dot size
    }
  `;

  // Fragment shader source
  const fragmentShaderSrc = `
    precision mediump float;
    uniform vec2 u_mouse;  // Mouse position (normalized)
    uniform float u_radius;  // Mouse interaction radius
    uniform vec2 u_resolution;
    void main() {
      // Calculate distance from mouse
      float dist = distance(gl_FragCoord.xy, vec2(u_mouse.x, u_resolution.y - u_mouse.y));

      // Calculate brightness (closer = brighter)
      float brightness = 1.0 - smoothstep(0.0, u_radius, dist);

      // Set dot color using OKLCH-inspired values
      float l = brightness;
      gl_FragColor = vec4(l * 0.0235294118, l * 0.6823529412, l * 0.8666666667, 1.0);  // RGB based on brightness
    }
  `;

  // Compile shader
  function createShader(
    gl: WebGLRenderingContext,
    type: number,
    source: string,
  ) {
    const shader = gl.createShader(type);
    if (!shader) {
      throw new Error("unable to create shader!");
    }
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
      console.error("Shader compile failed:", gl.getShaderInfoLog(shader));
      gl.deleteShader(shader);
      return null;
    }
    return shader;
  }

  // Create WebGL program
  const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSrc);
  const fragmentShader = createShader(
    gl,
    gl.FRAGMENT_SHADER,
    fragmentShaderSrc,
  );

  if (!(vertexShader && fragmentShader)) {
    throw new Error("unable to create shaders!");
  }

  const program = gl.createProgram();
  gl.attachShader(program, vertexShader);
  gl.attachShader(program, fragmentShader);
  gl.linkProgram(program);
  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
    console.error("Program link failed:", gl.getProgramInfoLog(program));
  }
  gl.useProgram(program);

  // Create grid of dot positions
  const DOT_SPACING = 40;
  const positions = [];
  for (let x = 0; x < canvas.width; x += DOT_SPACING) {
    for (let y = 0; y < canvas.height; y += DOT_SPACING) {
      positions.push(x, y);
    }
  }

  // Upload positions to GPU
  const positionBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);

  const aPosition = gl.getAttribLocation(program, "a_position");
  gl.enableVertexAttribArray(aPosition);
  gl.vertexAttribPointer(aPosition, 2, gl.FLOAT, false, 0, 0);

  // Uniforms
  const uResolution = gl.getUniformLocation(program, "u_resolution");
  const uMouse = gl.getUniformLocation(program, "u_mouse");
  const uRadius = gl.getUniformLocation(program, "u_radius");

  gl.uniform2f(uResolution, canvas.width, canvas.height);
  let mouseX = canvas.width / 2;
  let mouseY = canvas.height / 2;
  const MOUSE_RADIUS = 150;

  // Update mouse position
  document.addEventListener("mousemove", (e) => {
    mouseX = e.clientX + window.scrollX;
    mouseY = e.clientY + window.scrollY; // Flip y-axis
  });

  // Render loop
  function render() {
    gl.clear(gl.COLOR_BUFFER_BIT);
    gl.uniform2f(uMouse, mouseX, mouseY);
    gl.uniform1f(uRadius, MOUSE_RADIUS);

    gl.drawArrays(gl.POINTS, 0, positions.length / 2);
    requestAnimationFrame(render);
  }
  render();
</script>

<style>
  /* body {
    margin: 0;
    overflow: hidden;
    background-color: black;
  } */
  #dotCanvas {
    position: absolute;
    top: 0;
    left: 0;
    z-index: -1;
    /* pointer-events: none; */
    filter: blur(5px);
  }
</style>
