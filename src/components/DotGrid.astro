<canvas id="dotCanvas" transition:persist></canvas>

<script>
  // WebGL setup
  const canvas = document.getElementById("dotCanvas") as HTMLCanvasElement;

  function calcCanvas() {
    const scrollWidth = document.scrollingElement?.scrollWidth ?? 0;
    const scrollHeight = document.scrollingElement?.scrollHeight ?? 0;
    canvas.width = Math.max(scrollWidth, window.innerWidth) - 1;
    canvas.height = Math.max(scrollHeight, window.innerHeight) - 1;
  }

  calcCanvas();

  const gl = canvas.getContext("webgl");
  if (!gl) {
    console.error("WebGL not supported!");
    throw new Error("WebGL not supported.");
  }

  // OKLCH to RGB, thanks Hazel
  const oklchToRgb = `#define PI 3.1415926535

  vec3 oklch2oklab(vec3 lch) {
      return vec3(
          lch.x,
          lch.y * cos(lch.z * PI / 180.0),
          lch.y * sin(lch.z * PI / 180.0)
      );
  }
  vec3 oklab2xyz(vec3 lab) {
      vec3 LMSg = mat3(
          1.0,                 1.0,                 1.0,
          0.3963377773761749, -0.1055613458156586, -0.0894841775298119,
          0.2158037573099136, -0.0638541728258133, -1.2914855480194092
      ) * lab;
      vec3 LMS = vec3(pow(LMSg.x, 3.0), pow(LMSg.y, 3.0), pow(LMSg.z, 3.0));
      return mat3(
          1.2268798758459243, -0.0405757452148008, -0.0763729366746601,
         -0.5578149944602171,  1.1122868032803170, -0.4214933324022432,
          0.2813910456659647, -0.0717110580655164,  1.5869240198367816
      ) * LMS;
  }
  vec3 xyz2rgbLinear(vec3 xyz) {
      return mat3(
          3.2409699419045226, -0.9692436362808796,  0.05563007969699366,
         -1.537383177570094,   1.8759675015077202, -0.20397695888897652,
         -0.4986107602930034,  0.04155505740717559, 1.0569715142428786
      ) * xyz;
  }
  vec3 srgbLinear2rgb(vec3 lch) {
      return vec3(
          abs(lch.r) > 0.0031308 ?
          (lch.r < 0.0 ? -1.0 : 1.0) * (1.055 * pow(abs(lch.r), (1.0 / 2.4)) - 0.055) :
          12.92 * lch.r,
          abs(lch.g) > 0.0031308 ?
          (lch.g < 0.0 ? -1.0 : 1.0) * (1.055 * pow(abs(lch.g), (1.0 / 2.4)) - 0.055) :
          12.92 * lch.g,
          abs(lch.b) > 0.0031308 ?
          (lch.b < 0.0 ? -1.0 : 1.0) * (1.055 * pow(abs(lch.b), (1.0 / 2.4)) - 0.055) :
          12.92 * lch.b
      );
  }
  vec3 oklch2rgb(vec3 lch)
  {
      return srgbLinear2rgb(xyz2rgbLinear(oklab2xyz(oklch2oklab(lch))));
  }`;

  // Vertex shader source
  const vertexShaderSrc = `
    precision mediump float;
    attribute vec2 a_position;  // Dot position (normalized)
    uniform vec2 u_resolution;  // Canvas resolution
    uniform vec2 u_mouse;
    uniform float u_radius;
    void main() {
      // Convert position to clip space [-1, 1]
      vec2 clipSpace = (a_position / u_resolution) * 2.0 - 1.0;
      gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);
      gl_PointSize = 4.0 + max(0.0, u_radius - distance(a_position, u_mouse)) / 25.0;  // Base dot size
    }
  `;

  // Fragment shader source
  const fragmentShaderSrc = `
    precision mediump float;
    uniform vec2 u_mouse;  // Mouse position (normalized)
    uniform float u_radius;  // Mouse interaction radius
    uniform vec2 u_resolution;
    uniform int u_dark;

    ${oklchToRgb}

    void main() {
      // Calculate distance from mouse
      float dist = distance(gl_FragCoord.xy, vec2(u_mouse.x, u_resolution.y - u_mouse.y));

      // Calculate brightness (closer = brighter)
      float brightness = 1.0 - smoothstep(0.0, u_radius, dist);

      // Set dot color using OKLCH-inspired values
      float l = brightness;
      float dark = float(u_dark);
      gl_FragColor = vec4(oklch2rgb(vec3((1.0 - dark) * l + dark * (1.0- l * 0.75), 0.1332, 226.06)), 1.0);  // RGB based on brightness
    }
  `;

  // Compile shader
  function createShader(
    gl: WebGLRenderingContext,
    type: number,
    source: string,
  ) {
    const shader = gl.createShader(type);
    if (!shader) {
      throw new Error("unable to create shader!");
    }
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
      console.error("Shader compile failed:", gl.getShaderInfoLog(shader));
      gl.deleteShader(shader);
      return null;
    }
    return shader;
  }

  // Create WebGL program
  const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSrc);
  const fragmentShader = createShader(
    gl,
    gl.FRAGMENT_SHADER,
    fragmentShaderSrc,
  );

  if (!(vertexShader && fragmentShader)) {
    throw new Error("unable to create shaders!");
  }

  const program = gl.createProgram();
  gl.attachShader(program, vertexShader);
  gl.attachShader(program, fragmentShader);
  gl.linkProgram(program);
  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
    console.error("Program link failed:", gl.getProgramInfoLog(program));
  }
  gl.useProgram(program);

  const positionBuffer = gl.createBuffer();
  const aPosition = gl.getAttribLocation(program, "a_position");
  let positions: number[] = [];
  function generateDots() {
    // Create grid of dot positions
    const DOT_SPACING = 40;
    positions = [];
    for (let x = DOT_SPACING / 2; x < canvas.width; x += DOT_SPACING) {
      for (let y = DOT_SPACING / 2; y < canvas.height; y += DOT_SPACING) {
        positions.push(x, y);
      }
    }

    // Upload positions to GPU
    gl!.bindBuffer(gl!.ARRAY_BUFFER, positionBuffer);
    gl!.bufferData(
      gl!.ARRAY_BUFFER,
      new Float32Array(positions),
      gl!.STATIC_DRAW,
    );

    gl!.enableVertexAttribArray(aPosition);
    gl!.vertexAttribPointer(aPosition, 2, gl!.FLOAT, false, 0, 0);
  }

  generateDots();

  // Uniforms
  const uResolution = gl.getUniformLocation(program, "u_resolution");
  const uMouse = gl.getUniformLocation(program, "u_mouse");
  const uRadius = gl.getUniformLocation(program, "u_radius");
  const uDark = gl.getUniformLocation(program, "u_dark");

  let mouseX = canvas.width / 2;
  let mouseY = canvas.height / 2;

  const MOUSE_RADIUS = 150;

  // Update mouse position
  document.addEventListener("mousemove", (e) => {
    mouseX = e.clientX;
    mouseY = e.clientY;
  });

  window.addEventListener("resize", () => {
    calcCanvas();
    generateDots();
  });

  document.addEventListener("astro:page-load", () => {
    // This runs on first page load and after every navigation.
    console.log("hi");

    console.log(document.scrollingElement!.scrollHeight);
    calcCanvas();
    generateDots();
  });

  let isDarkMode =
    window.matchMedia &&
    window.matchMedia("(prefers-color-scheme: dark)").matches;
  window
    .matchMedia("(prefers-color-scheme: dark)")
    .addEventListener("change", (event) => {
      isDarkMode = event.matches;
    });

  gl.uniform1f(uRadius, MOUSE_RADIUS);
  // Render loop
  function render() {
    gl!.viewport(0, 0, canvas.width, canvas.height);
    gl!.uniform2f(uResolution, canvas.width, canvas.height);
    if (isDarkMode) {
      gl!.clearColor(0.0117647059, 0.0274509804, 0.0705882353, 1.0);
    } else {
      gl!.clearColor(0.9764705882, 0.9803921569, 0.9843137255, 1.0);
    }
    gl!.clear(gl!.COLOR_BUFFER_BIT);
    gl!.uniform2f(uMouse, mouseX + window.scrollX, mouseY + window.scrollY);
    gl!.uniform1i(uDark, isDarkMode ? 1 : 0);

    gl!.drawArrays(gl!.POINTS, 0, positions.length / 2);
    requestAnimationFrame(render);
  }
  render();
</script>

<style>
  body {
    margin: 0;
    /* overflow: hidden; */
    /* background-color: black; */
  }
  #dotCanvas {
    position: absolute;
    top: 0;
    left: 0;
    z-index: -1;
    pointer-events: none;
    filter: blur(5px);
    overflow: hidden;
  }
</style>
