<canvas id="dotCanvas"></canvas>

<script>
  // WebGL setup
  const canvas = document.getElementById("dotCanvas") as HTMLCanvasElement;
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;

  const gl = canvas.getContext("webgl");
  if (!gl) {
    console.error("WebGL not supported!");
    throw new Error("WebGL not supported.");
  }

  // OKLCH to RGB, thanks Hazel
  const oklchToRgb = `#define PI 3.1415926535

  vec3 oklch2oklab(vec3 lch) {
      return vec3(
          lch.x,
          lch.y * cos(lch.z * PI / 180.0),
          lch.y * sin(lch.z * PI / 180.0)
      );
  }
  vec3 oklab2xyz(vec3 lab) {
      vec3 LMSg = mat3(
          1.0,                 1.0,                 1.0,
          0.3963377773761749, -0.1055613458156586, -0.0894841775298119,
          0.2158037573099136, -0.0638541728258133, -1.2914855480194092
      ) * lab;
      vec3 LMS = vec3(pow(LMSg.x, 3.0), pow(LMSg.y, 3.0), pow(LMSg.z, 3.0));
      return mat3(
          1.2268798758459243, -0.0405757452148008, -0.0763729366746601,
         -0.5578149944602171,  1.1122868032803170, -0.4214933324022432,
          0.2813910456659647, -0.0717110580655164,  1.5869240198367816
      ) * LMS;
  }
  vec3 xyz2rgbLinear(vec3 xyz) {
      return mat3(
          3.2409699419045226, -0.9692436362808796,  0.05563007969699366,
         -1.537383177570094,   1.8759675015077202, -0.20397695888897652,
         -0.4986107602930034,  0.04155505740717559, 1.0569715142428786
      ) * xyz;
  }
  vec3 srgbLinear2rgb(vec3 lch) {
      return vec3(
          abs(lch.r) > 0.0031308 ?
          (lch.r < 0.0 ? -1.0 : 1.0) * (1.055 * pow(abs(lch.r), (1.0 / 2.4)) - 0.055) :
          12.92 * lch.r,
          abs(lch.g) > 0.0031308 ?
          (lch.g < 0.0 ? -1.0 : 1.0) * (1.055 * pow(abs(lch.g), (1.0 / 2.4)) - 0.055) :
          12.92 * lch.g,
          abs(lch.b) > 0.0031308 ?
          (lch.b < 0.0 ? -1.0 : 1.0) * (1.055 * pow(abs(lch.b), (1.0 / 2.4)) - 0.055) :
          12.92 * lch.b
      );
  }
  vec3 oklch2rgb(vec3 lch)
  {
      return srgbLinear2rgb(xyz2rgbLinear(oklab2xyz(oklch2oklab(lch))));
  }`;

  // Vertex shader source
  const vertexShaderSrc = `
    precision mediump float;
    attribute vec2 a_position;  // Dot position (normalized)
    uniform vec2 u_resolution;  // Canvas resolution
    uniform vec2 u_mouse;
    uniform float u_radius;
    void main() {
      // Convert position to clip space [-1, 1]
      vec2 clipSpace = (a_position / u_resolution) * 2.0 - 1.0;
      gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);
      gl_PointSize = 4.0 + max(0.0, u_radius - distance(a_position, u_mouse)) / 30.0;  // Base dot size
    }
  `;

  // Fragment shader source
  const fragmentShaderSrc = `
    precision mediump float;
    uniform vec2 u_mouse;  // Mouse position (normalized)
    uniform float u_radius;  // Mouse interaction radius
    uniform vec2 u_resolution;

    ${oklchToRgb}

    void main() {
      // Calculate distance from mouse
      float dist = distance(gl_FragCoord.xy, vec2(u_mouse.x, u_resolution.y - u_mouse.y));

      // Calculate brightness (closer = brighter)
      float brightness = 1.0 - smoothstep(0.0, u_radius, dist);

      // Set dot color using OKLCH-inspired values
      float l = brightness;
      gl_FragColor = vec4(oklch2rgb(vec3(l, 0.1332, 226.06)), 1.0);  // RGB based on brightness
    }
  `;

  // Compile shader
  function createShader(
    gl: WebGLRenderingContext,
    type: number,
    source: string,
  ) {
    const shader = gl.createShader(type);
    if (!shader) {
      throw new Error("unable to create shader!");
    }
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
      console.error("Shader compile failed:", gl.getShaderInfoLog(shader));
      gl.deleteShader(shader);
      return null;
    }
    return shader;
  }

  // Create WebGL program
  const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSrc);
  const fragmentShader = createShader(
    gl,
    gl.FRAGMENT_SHADER,
    fragmentShaderSrc,
  );

  if (!(vertexShader && fragmentShader)) {
    throw new Error("unable to create shaders!");
  }

  const program = gl.createProgram();
  gl.attachShader(program, vertexShader);
  gl.attachShader(program, fragmentShader);
  gl.linkProgram(program);
  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
    console.error("Program link failed:", gl.getProgramInfoLog(program));
  }
  gl.useProgram(program);

  // Create grid of dot positions
  const DOT_SPACING = 40;
  const positions = [];
  for (let x = 0; x < canvas.width; x += DOT_SPACING) {
    for (let y = 0; y < canvas.height; y += DOT_SPACING) {
      positions.push(x, y);
    }
  }

  // Upload positions to GPU
  const positionBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);

  const aPosition = gl.getAttribLocation(program, "a_position");
  gl.enableVertexAttribArray(aPosition);
  gl.vertexAttribPointer(aPosition, 2, gl.FLOAT, false, 0, 0);

  // Uniforms
  const uResolution = gl.getUniformLocation(program, "u_resolution");
  const uMouse = gl.getUniformLocation(program, "u_mouse");
  const uRadius = gl.getUniformLocation(program, "u_radius");

  gl.uniform2f(uResolution, canvas.width, canvas.height);
  let mouseX = canvas.width / 2;
  let mouseY = canvas.height / 2;
  const MOUSE_RADIUS = 150;

  // Update mouse position
  document.addEventListener("mousemove", (e) => {
    mouseX = e.clientX + window.scrollX;
    mouseY = e.clientY + window.scrollY; // Flip y-axis
  });

  // Render loop
  function render() {
    gl.clear(gl.COLOR_BUFFER_BIT);
    gl.uniform2f(uMouse, mouseX, mouseY);
    gl.uniform1f(uRadius, MOUSE_RADIUS);

    gl.drawArrays(gl.POINTS, 0, positions.length / 2);
    requestAnimationFrame(render);
  }
  render();
</script>

<style>
  /* body {
    margin: 0;
    overflow: hidden;
    background-color: black;
  } */
  #dotCanvas {
    position: absolute;
    top: 0;
    left: 0;
    z-index: -1;
    /* pointer-events: none; */
    filter: blur(5px);
  }
</style>
